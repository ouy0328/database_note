---

---

# 数据模型

## 06. 层次数据模型

### 基本概念

![](https://cdn.jsdelivr.net/gh/ouy0328/note_picture/img/20221220151915.png)

由于显示世界中的许多事物之间存在层次关系，层析数据模型用树来描述这些关系。

- 记录 (record)：把显示世界的一个实体表达为一个记录
- 域 (field)：一个记录由若干个域来描述
- 双亲子女关系 (PCR)：层次数据模型中最基本的数据关系。它表示两个数据类型间一对多的关系。

### 层次数据模式

![](https://cdn.jsdelivr.net/gh/ouy0328/note_picture/img/20221220154346.png)

- 一个层次数据模式包含多个PCR
- 每一个PCR表示一个一对多的关系
- 每一个记录类型只能有一个父节点

### 虚记录

![](https://cdn.jsdelivr.net/gh/ouy0328/note_picture/img/20221220160454.png)

在现实世界，许多数据不是层次型，它们很难直接用PCR表示出来。

- 不同记录间多对多的关系
- 一个记录类型可能有多个父节点
- 多元关系

![](https://cdn.jsdelivr.net/gh/ouy0328/note_picture/img/20221220162120.png)

为避免冗余，引入虚拟记录来表达上述关系。它实际上是指针，由虚记录指向真实记录。

## 07. 网状数据模型

### 基本概念

![](https://cdn.jsdelivr.net/gh/ouy0328/note_picture/img/20230103155253.png)

- 网状数据模型的基本数据结构为系 (set)，表达显示世界中两个数据类型一对多的关系。其中一为主记录，多为属记录。在网状数据模型中，一个记录类型可以为多个系的主记录，也可以是多个系的属记录。
- 突破了层次数据结构的限制，比层次模型更加容易地表达显示世界。
- 网状数据模型

### 举例

![](https://cdn.jsdelivr.net/gh/ouy0328/note_picture/img/20230103160002.png)

主记录：Class

属记录：Student

## 08. 关系数据模型
### 基本概念

![](https://cdn.jsdelivr.net/gh/ouy0328/database_note/img/20230207152031.png)
- 在关系模型中，基本的数据结构只有一种“表(table)”，或叫做关系(relation)。现实世界中的实体和实体之间的关系全部用表来表示，所以它所以可以用严格的数学方法研究。
  - 基于数学中的集合论，拥有更高的抽象级别。
  
  - 屏蔽了所有底层的实现，包括编程细节。整个数据模型的概念非常简单、清楚、容易理解。
  
  - 可以建立新的代数系统——关系代数
  
  - 非过程化的查询语言，不需要程序员自己编写程序——SQL
  
  - 软连接——可以看成一种逻辑指针。
  
    举例：
  
    ![](https://cdn.jsdelivr.net/gh/ouy0328/database_note/img/20230207154443.png)

### 基本术语和概念

#### 属性和域

![](https://cdn.jsdelivr.net/gh/ouy0328/database_note/img/20230207155854.png)
- 现实世界中实体的特征表示为属性
  - 一个学生可以被如下属性描述：姓名、学号、性别、年龄、生日、国籍等。
- 一个属性的取值范围被称为它的域。
  - 原子数据（基本数据类型，不可再分）——第一范式
  - 允许属性的值为空值（空值为未知，不是0也不是空串）
#### 关系和元组
![](https://cdn.jsdelivr.net/gh/ouy0328/database_note/img/20230207162647.png)
- 现实世界的实体以及实体之间的联系可以用一个或多个关系来表达。关系实际上就是在它属性的值域上定义的一个N元联系。 简称为表。
- 表内的每一行为一个元组。

#### 主键

![](https://cdn.jsdelivr.net/gh/ouy0328/database_note/img/20230208142711.png)

##### 候选键定义

满足以下条件的属性被称为候选键：

- 关系内任意两条不同元组的这个值都不一样，或者说这组属性的值能够唯一确定其他属性的值。
- 这组属性的任意一个子集没有这个特性。

满足第一个条件但不满足第二个条件则被称为超键。

##### 主键定义

候选键可能有多个，可以指定其中一个为主键，其他为候补键。

主键可能是由关系内所有属性组成，这种主键称为全键。

#### 外键

![](https://cdn.jsdelivr.net/gh/ouy0328/database_note/img/20230208152104.png)

##### 定义

在一个关系内，由一组属性用来引用另一张表内的元组，那么这一组属性就被称为外键。外键应该是被引用的表的主键。

##### 引用完整性

如果把外键堪称一个逻辑指针，那么该逻辑指针不能当空（不能指向空值）。

##### 举例

![](https://cdn.jsdelivr.net/gh/ouy0328/database_note/img/20230208160052.png)

选课表通过sid引用学生表中的内容。

#### 完整性约束

- 通过外键的引用完整性约束
- 域完整性约束：一张表中每条元组的每一个属性的值都必须符合它的值域的要求。
- 实体完整性约束：关系内主键的值不能为空，主键为空则不能唯一标识一个元组。

##### 举例

![](https://cdn.jsdelivr.net/gh/ouy0328/database_note/img/20230208160606.png)

- S1和S2为水手信息表，sid 水手编号 sname 水手姓名 rateing 水手级别 age 水手年龄，主键为sid
- B1为船只信息表，bid 船只编号 bname 船只名字 color 船只颜色，主键为bid
- R1为水手和船只之间的预定关系表，sid 水手编号 bid 船只编号 day 预定日期，主键为全键

## 09. 关系代数基本操作

关系代数是关系模型的理论基础

### 五个基本操作

![](https://cdn.jsdelivr.net/gh/ouy0328/database_note/img/20230208163147.png)

- selection(σ)：选择操作，从一个表中筛选出符合条件的元组。
- projection(π)：投影操作，删除表中不需要的列
- cross-product(×)：笛卡尔乘积，将两个关系拼接在一起，拼成一个大的关系
- set-difference(－)：集合差操作，找出属于关系①但不属于关系②的元组
- union(∪)：集合并操作，把两个模式相同的元组合并起来

#### 其他操作

不是必须的，但非常有用

- intersection 集合交集
- join 两个表连接操作
- division 除法操作
- outer join 外连接
- outer union 外并

#### 投影操作

![](https://cdn.jsdelivr.net/gh/ouy0328/database_note/img/20230208172547.png)

删除一个关系中不想要的属性。

投影操作的结果还是一个关系，关系模式由投影操作因算符中的属性组成。

投影操作需要消除重复元组。

实际数据库系统在进行投影操作是不会主动删除重复元组，除非用户主动要求。

##### 举例

- 将S2投影到姓名和级别两列上
- 将S2投影到年龄列上，需要消除重复的元组来得到结果

#### 选择操作

![](https://cdn.jsdelivr.net/gh/ouy0328/database_note/img/20230209143507.png)

选择操作就是在一张表中选出符合条件的元组。

选择操作不会出现重复元组。

选择操作结果的关系模式与原关系模式完全相同。

选择操作的结果就是原关系里面满足布尔条件的元组。

##### 举例

- 选出级别大于8的水手
- 先选择级别大于8的水手，再将选择操作的结果投影到姓名和年龄两列上

#### 集合的并、交、差（二元操作）

![](https://cdn.jsdelivr.net/gh/ouy0328/database_note/img/20230209150321.png)

参与运算的两个集合必须满足并兼容的条件，即两个关系必须由相同个数的属性而且对用属性的类型必须一样

#### 笛卡尔乘积

![](https://cdn.jsdelivr.net/gh/ouy0328/database_note/img/20230209150704.png)

笛卡尔乘积的结果模式包含原来两张表中的所有属性，把原来参与笛卡尔乘积的两张表的属性并起来。结果的元组由原来两张表中的元组两两拼接而成。

##### 举例

S1×R1

- S1的每一行和R1进行配对
- 结果模式包含S1和R1的所有属性，并且属性名称会被继承
  - 冲突：S1和R1中都包含名为 sid 的属性

| (sid) | sname  | rating | age  | (sid) | bid  | day      |
| ----- | ------ | ------ | ---- | ----- | ---- | -------- |
| 22    | dustin | 7      | 45.0 | 22    | 101  | 10/10/96 |
| 22    | dustin | 7      | 45.0 | 58    | 103  | 11/12/96 |
| 31    | lubber | 8      | 55.5 | 22    | 101  | 10/10/96 |
| 31    | lubber | 8      | 555  | 58    | 103  | 11/12/96 |
| 58    | rusty  | 10     | 35.0 | 22    | 101  | 10/10/96 |
| 58    | rusty  | 10     | 35.0 | 58    | 103  | 11/12/96 |

## 10. 关系代数连接操作
#### 条件连接

![](https://cdn.jsdelivr.net/gh/ouy0328/database_note/img/20230209155544.png)

关系R和关系S按照某一条件C做连接操作等于先对关系R和关系S做笛卡尔乘积，在笛卡尔乘积的结果上再按条件C做选择操作。

- 条件连接的结果模式与笛卡尔乘积的结果模式相同
- 元组数量较笛卡尔乘积的结果要少，可以更有效的计算。
- 有时被称为θ连接

#### 等值连接

![](https://cdn.jsdelivr.net/gh/ouy0328/database_note/img/20230209162034.png)

如果在条件连接的条件C中值出现属性相等的等值判断的话，就叫做等值连接。

- 等值连接的结果模式与笛卡尔乘积的结果模式类似，但是去掉了重复的等值属性列。
- 自然连接：在两张表所有的公共属性上做等值连接。


## 11. 关系代数除法和外连接操作
#### 除法操作

![](https://cdn.jsdelivr.net/gh/ouy0328/database_note/img/20230209164801.png)

除法连接不是关系代数中的基本操作，但是在实际开发中会经常使用，例如“查找借过所有船只的水手”。

关系A由x和y两个属性组成，关系B由y属性组成。那么关系A除以关系B的结果就是由即在关系A中也在关系B中的y值对应在关系A中的x属性组成的。

##### 举例

![](https://cdn.jsdelivr.net/gh/ouy0328/database_note/img/20230209171555.png)
![](https://cdn.jsdelivr.net/gh/ouy0328/database_note/img/20230210140512.png)



#### 外连接

将自然连接中不满足连接操作的元组保留下来。

- 左外连接：把连接运算符的左边的所有元组都保留下来，找不到匹配的补空值
- 右外连接：把连接运算符的右边的所有元组都保留下来，找不到匹配的补空值
- 全外连接：把连接运算符的左右两边的所有元组都保留下来，找不到匹配的补空值

##### 举例

![](https://cdn.jsdelivr.net/gh/ouy0328/database_note/img/20230210145842.png)

#### 外并

![](https://cdn.jsdelivr.net/gh/ouy0328/database_note/img/20230210150036.png)

将两个不满足并兼容条件的关系强行并在一起。

外并结果的属性集是参与运算的两个关系的属性的并，元组也是参与运算的两个关系的元组的并，单一存在的补空值。

## 12. 关系演算

![](https://cdn.jsdelivr.net/gh/ouy0328/database_note/img/20230210154709.png)
![](https://cdn.jsdelivr.net/gh/ouy0328/database_note/img/20230210160640.png)

关系代数需要指定运算顺序；而关系盐酸只需要指出结果必须满足的逻辑条件。

关系演算有两种形式：元组关系演算(TRC)和域关系演算(DRC)，区别在于对变量的定义。元组关系演算以元组为单位来定义变量，域关系演算是以属性为单位来定义变量。

在关系演算中存在各种不同的布尔表达式，这些表达式被称为公式。查询结果就是能够使公式为真的表里的元组所组成的属性的集合。

### 域关系演算

![](https://cdn.jsdelivr.net/gh/ouy0328/database_note/img/20230213145451.png)

![](https://cdn.jsdelivr.net/gh/ouy0328/database_note/img/20230213150215.png)

在域关系演算中，是把变量定义在属性上的，每一个变量表示一个属性。

查询的一般形式为：{ < x1,x2,…,xn > | P ( x1,x2,…,xn,xn+1,…,xn+m ) }

在要查新的属性上定义一组变量，根据需求定义布尔表达式，找出满足布尔表达式的元组。布尔表达式从原子公式开始，再利用逻辑连接符构成更复杂、更大的公式。

#### 域关系模式中的原子公式

![](https://cdn.jsdelivr.net/gh/ouy0328/database_note/img/20230210164323.png)
![](https://cdn.jsdelivr.net/gh/ouy0328/database_note/img/20230210164453.png)

- <x1,x2,…,xn> ∈ Rname  一组域变量所组成的元组属于某个关系，表明这 n 个变量的某一组取值所形成的元组属于这个关系。
- X op Y 或 X op constant(常量) X 是一个变量，Y 也是一个变量，表示关系中的某个属性。op 为比较运算符，即大于等于小于等于大于等于不等于

#### 域关系模式中的公式定义

- 一个原子公式就是一个公式
- 若p和q均为公式，那么**¬** p, p∧q, p∨q (否定p，p与q，p或q) 也是公式
- 若p是一个公式，那么∃X(p(X))是一个公式。其中公式p内的X是free的（X没有绑定，量词不能重复使用）
- 若p是一个公式，那么∀X(p(X))是一个公式。其中公式p内的X是free的（X没有绑定，量词不能重复使用）

##### 自由变量和绑定变量

![](https://cdn.jsdelivr.net/gh/ouy0328/database_note/img/20230213152145.png)

如果再一个域变量内使用存在量词或全称量词，那我们就说这个X被绑定了。

一个变量如果没有被绑定就是自由变量。

#### 域关系演算举例

![](https://cdn.jsdelivr.net/gh/ouy0328/database_note/img/20230213152722.png)

查询所有级别大于 7 的水手。

- { <I,N,T,A> | <I,N,T,A> ∈ Sailors ∧ T>7 }

  I, N, T, A 这四个变量组成一个元组属于Sailors，并且T(级别)属性的值大于 7

![image-20230213153346910](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20230213153346910.png)

- { <I,N,T,A> | <I,N,T,A> ∈ Sailors ∧ T<9 ^ A='Joe' ∧ A>18 }

#### 安全查询问题以及关系运算表达能力问题

![](https://cdn.jsdelivr.net/gh/ouy0328/database_note/img/20230213153943.png)
![](https://cdn.jsdelivr.net/gh/ouy0328/database_note/img/20230213154450.png)

- 满足公式的结果可能无限多，为不安全查询。

- 任何可以用关系代数表示的查询都可以表示为 DRC / TRC 中的安全查询，它们的表达能力是等价的。

- 关系代数中五个基本操作是一个完备的操作集合。这五个操作我们都可以用关系演算很容易的等价的把它表达出来。

  关系代数与关系演算的表达能力等价，只是考虑问题的角度和表达方式不同。关系代数是一种过程化的表达方式，关系演算是一种非过程化的表达方式。

  SQL语言是建立在关系演算之上的，以关系演算为理论基础的。用关系代数和关系演算所能够表达的任何查询，使用SQL语言也能够同样的表达。

### 元组关系演算

除变量使用外，与域关系演算完全相同。

#### 元组关系演算举例

![](https://cdn.jsdelivr.net/gh/ouy0328/database_note/img/20230213160048.png)

变量 t 是定义在元组上的一个变量，t 表明一条元组。

- 查询的一般形式为：{ t [ <attribute list> ] | P(t) }
- 查询结果为是公式P(t)为真的所有元组t<attribute list>

##### 举例

找出所有级别大于 7 且小于 50 的水手的姓名

{ t[N] | t ∈ Sailors ∧ t.T>7 ∧ t.A<50 }

N：水手姓名

T：水手级别

A：水手年龄

## 13. 传统数据模型评价

![](https://cdn.jsdelivr.net/gh/ouy0328/database_note/img/20230213164556.png)

- 层次、网状和关系模型统称为传统数据模型
- 适用于传统的OLTP (Online Transaction Processing，联机事务处理) 应用
- 基于记录，不能很好的面向用户和应用
- 不能用很自然的方法来表达现实世界实体之间的联系，表达能力有限
- 模型本身缺乏语义信息
- 支持的数据类型太少，难以满足应用需求

## 14. ER数据模型和面向对象数据模型

### ER数据模型

#### 概念

![](https://cdn.jsdelivr.net/gh/ouy0328/database_note/img/20230213170313.png)
![](https://cdn.jsdelivr.net/gh/ouy0328/database_note/img/20230214143434.png)

- 实体：将现实世界中可区别、可区分的事物或对象都表达为实体，一个实体是由一组属性来描述的。
- 实体集：一组类似实体组成的集合就叫实体集。
  - 一个实体集中的所有实体拥有相同的属性
  - 每一个实体有一个键
  - 每一个属性有一个域
  - 允许有复合类型的属性，允许有多值的属性

#### 联系

![](https://cdn.jsdelivr.net/gh/ouy0328/database_note/img/20230214143948.png)

- 联系：现实世界中两个或多个实体之间的关系就叫做联系。
  - 联系可以有属性
- 联系集：所有相同类型联系组成的集合就叫做联系集。
  - 一个联系集是组成这个联系的 n 个实体之间组成的 n 元关系
  - 同一个实体集可以参与不同的联系，或在同一个联系集中充当不同的角色

#### ER 图

![](https://cdn.jsdelivr.net/gh/ouy0328/database_note/img/20230214144814.png)
![](https://cdn.jsdelivr.net/gh/ouy0328/database_note/img/20230214145013.png)

- 概念模型：实体-关系，独立于实际的DBMS

- 长方形：实体集

  菱形：联系集

  圆圈：实体或联系的属性

#### 语义约束

##### 基数比约束

![](https://cdn.jsdelivr.net/gh/ouy0328/database_note/img/20230214164420.png)

- 实体集之间的联系可以分成一对一、一对多、多对一和多对多这样一些类型。

##### 参与度约束

![](https://cdn.jsdelivr.net/gh/ouy0328/database_note/img/20230214165046.png)

- 可以规定每一个实体参与某一个联系的最小和最大次数。

#### 扩展的 ER 模型 ( EER )

![](https://cdn.jsdelivr.net/gh/ouy0328/database_note/img/20230214171752.png)

- 弱实体：不能单独存在，必须依赖于其他实体存在的实体。用双线表示。
  - 例：有实体职工与职工家属，职工家属依赖于职工，即职工家属为弱实体。
- 普遍化与特殊化：类似于面向对象数据模型中的父类与子类之间的集成；特殊化相当于子类，拥有父类的基本特性，在此基础上有几倍一些特殊的特性；普遍化则为反过来。
  - 例：有实体学生与研究生，研究生既是学生又是研究生，则从学生到研究生为特殊化；反过来从研究生到学生为普遍化。
- 聚集：在有些应用中，允许把两个实体集之间的联系也看作实体集，在让这个实体集与其他实体集建立联系。
  - 例：![](https://cdn.jsdelivr.net/gh/ouy0328/database_note/img/20230214171045.png)
- 范畴：由不同类型的实体组成的一个集合，类似于面向对象模型中的杂种集合。
  - 例：银行账户包含对公账户和私人账户

### 面向对象数据类型

![](https://cdn.jsdelivr.net/gh/ouy0328/database_note/img/20230214171718.png)

- 关系数据模型存在一些不足。
- 突破了一范式的限制。
- 来自于软件设计中面向对象的需求分析和面向对象的程序设计。
- 为了解决面向对象的程序设计语言中所创建和生成的对象永久存储并有效方便的读取和加载问题。
- 对象关系型数据库系统，引入允许用户自行定义的抽象数据类型。
- 纯面向对象数据库系统

